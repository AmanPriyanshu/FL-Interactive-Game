<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Federated Learning Interactive Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Embedded CSS -->
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #1e1e1e;
      color: #ffffff;
      margin: 0;
      padding: 0;
    }
    header, footer {
      background-color: #2e2e2e;
      padding: 10px;
      text-align: center;
    }
    .container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      padding: 10px;
    }
    .client-panel {
      background-color: #333;
      border: 1px solid #444;
      border-radius: 5px;
      margin: 10px;
      padding: 10px;
      flex: 1 1 calc(50% - 40px); /* Adjust for margins */
      max-width: calc(50% - 40px);
    }
    @media (min-width: 768px) {
      .client-panel {
        flex: 1 1 calc(20% - 40px);
        max-width: calc(20% - 40px);
      }
    }
    .client-panel h3 {
      margin-top: 0;
    }
    .controls, .global-controls {
      margin-top: 10px;
    }
    .slider-label {
      display: flex;
      justify-content: space-between;
    }
    button {
      width: 100%;
      padding: 10px;
      margin-top: 10px;
      background-color: #4caf50;
      border: none;
      color: #fff;
      border-radius: 5px;
      cursor: pointer;
    }
    button:hover {
      background-color: #45a049;
    }
    .plot-container {
      width: 100%;
      max-width: 800px;
      margin: 0 auto;
    }
    .dropdown {
      margin: 10px;
      text-align: center;
    }
    .notification {
      background-color: #ff9800;
      padding: 10px;
      margin: 10px;
      border-radius: 5px;
    }
  </style>
</head>
<body>

<header>
  <h1>Federated Learning Interactive Game</h1>
</header>

<div class="dropdown">
  <label for="data-selection">Select Data Distribution:</label>
  <select id="data-selection">
    <option value="iid">IID</option>
    <option value="non-iid">Non-IID</option>
  </select>
</div>

<div class="container" id="client-container">
  <!-- Client panels will be injected here -->
</div>

<div class="global-controls">
  <div class="controls">
    <div class="slider-label">
      <label for="dropout-prob">Communication Dropout Probability:</label>
      <span id="dropout-value">0%</span>
    </div>
    <input type="range" id="dropout-prob" min="0" max="100" value="0">
  </div>
  <button id="run-all">Run All Local Trainings</button>
  <button id="aggregate">Aggregate Models</button>
</div>

<div class="plot-container">
  <canvas id="global-accuracy-plot"></canvas>
</div>

<div class="notification" id="notification" style="display: none;">
  <!-- Notifications will appear here -->
</div>

<footer>
  <p>Created for the 30 Days of PETs Challenge</p>
</footer>

<!-- Embedded JS -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
    // Initialize global variables
    const NUM_CLIENTS = 5;
    let clients = [];
    let serverModel;
    let globalTestData = { x: null, y: null };
    let dataDistribution = 'iid';
    let dropoutProbability = 0;

    // Initialize the application
    document.addEventListener('DOMContentLoaded', async () => {
      createClientPanels();
      await loadGlobalTestData();
      initializeServerModel();
      await reloadClientData(); // Ensure client data is loaded initially
      setupEventListeners();
      initializeGlobalPlot();
    });

  function createClientPanels() {
    const container = document.getElementById('client-container');
    container.innerHTML = '';
    for (let i = 1; i <= NUM_CLIENTS; i++) {
      const panel = document.createElement('div');
      panel.className = 'client-panel';
      panel.id = `client-${i}`;
      panel.innerHTML = `
        <h3>Client ${i}</h3>
        <div class="controls">
          <div class="slider-label">
            <label for="lr-${i}">Learning Rate:</label>
            <span id="lr-value-${i}">0.01</span>
          </div>
          <input type="range" id="lr-${i}" min="0.001" max="0.1" value="0.01" step="0.001">
          <div class="slider-label">
            <label for="epochs-${i}">Epochs:</label>
            <span id="epochs-value-${i}">1</span>
          </div>
          <input type="range" id="epochs-${i}" min="1" max="10" value="1">
        </div>
        <button id="train-local-${i}">Train Local</button>
        <canvas id="accuracy-plot-${i}" width="200" height="150"></canvas>
      `;
      container.appendChild(panel);
      clients.push({
        id: i,
        model: null,
        data: null,
        accuracyHistory: [],
        plot: null,
      });
    }
  }

  async function loadGlobalTestData() {
    // Load global test data by combining clients' test data
    globalTestData.x = [];
    globalTestData.y = [];
    for (let i = 1; i <= NUM_CLIENTS; i++) {
      const testData = await loadClientData(i, 'test');
      globalTestData.x.push(...testData.x);
      globalTestData.y.push(...testData.y);
    }
    // Convert to tensors
    globalTestData.x = tf.tensor2d(globalTestData.x);
    globalTestData.y = tf.tensor1d(globalTestData.y, 'int32');
  }

  function initializeServerModel() {
    // Create a simple MLP model
    serverModel = createModel();
  }

  function setupEventListeners() {
    // Data selection change
    document.getElementById('data-selection').addEventListener('change', async (e) => {
      dataDistribution = e.target.value;
      await reloadClientData();
    });

    // Dropout probability slider
    document.getElementById('dropout-prob').addEventListener('input', (e) => {
      dropoutProbability = parseInt(e.target.value);
      document.getElementById('dropout-value').innerText = `${dropoutProbability}%`;
    });

    // Train all clients
    document.getElementById('run-all').addEventListener('click', () => {
      clients.forEach((client) => trainLocalModel(client.id));
    });

    // Aggregate models
    document.getElementById('aggregate').addEventListener('click', aggregateModels);

    // Client-specific event listeners
    clients.forEach((client) => {
      // Learning rate slider
      document.getElementById(`lr-${client.id}`).addEventListener('input', (e) => {
        const lr = parseFloat(e.target.value);
        document.getElementById(`lr-value-${client.id}`).innerText = lr.toFixed(3);
      });

      // Epochs slider
      document.getElementById(`epochs-${client.id}`).addEventListener('input', (e) => {
        const epochs = parseInt(e.target.value);
        document.getElementById(`epochs-value-${client.id}`).innerText = epochs;
      });

      // Train local model
      document.getElementById(`train-local-${client.id}`).addEventListener('click', () => {
        trainLocalModel(client.id);
      });
    });
  }

  async function reloadClientData() {
    // Reload data for each client
    for (let client of clients) {
      client.data = await loadClientData(client.id, 'train');
    }
  }

  async function loadClientData(clientId, dataType) {
    const response = await fetch(`data/${dataDistribution}/client${clientId}.json`);
    const data = await response.json();
    const x = dataType === 'train' ? data.x_train : data.x_test;
    const y = dataType === 'train' ? data.y_train : data.y_test;
    return {
      x: x,
      y: y,
    };
  }

  function createModel() {
    const model = tf.sequential();
    model.add(tf.layers.dense({ units: 64, activation: 'relu', inputShape: [784] }));
    model.add(tf.layers.dense({ units: 10, activation: 'softmax' }));
    model.compile({
      optimizer: tf.train.adam(),
      loss: 'sparseCategoricalCrossentropy',
      metrics: ['accuracy'],
    });
    return model;
  }

  async function trainLocalModel(clientId) {
      const client = clients.find((c) => c.id === clientId);

      // Simulate communication dropout
      if (Math.random() < dropoutProbability / 100) {
        showNotification(`Client ${clientId} dropped out during communication.`);
        return;
      }

      // Load data if not already loaded
      if (!client.data) {
        client.data = await loadClientData(clientId, 'train');
      }

      // Get training parameters
      const lr = parseFloat(document.getElementById(`lr-${clientId}`).value);
      const epochs = parseInt(document.getElementById(`epochs-${clientId}`).value);

      // Create a new model and set its weights to the server model's weights
      client.model = createModel();
      client.model.setWeights(serverModel.getWeights());

      // Compile the model with the client's learning rate
      client.model.compile({
        optimizer: tf.train.adam(lr),
        loss: 'sparseCategoricalCrossentropy',
        metrics: ['accuracy'],
      });

      // Convert data to tensors
      const xTrain = tf.tensor2d(client.data.x);
      const yTrain = tf.tensor1d(client.data.y, 'int32');

      // Train the model
      await client.model.fit(xTrain, yTrain, {
        epochs: epochs,
        verbose: 0,
        callbacks: {
          onEpochEnd: async (epoch, logs) => {
            // Update local accuracy plot
            const acc = logs.acc;
            client.accuracyHistory.push(acc);
            updateClientPlot(clientId);
          },
        },
      });

      // Clean up tensors
      xTrain.dispose();
      yTrain.dispose();

      // Evaluate on the local test data
      const testData = await loadClientData(clientId, 'test');
      const xTest = tf.tensor2d(testData.x);
      const yTest = tf.tensor1d(testData.y, 'int32');
      const evalResult = client.model.evaluate(xTest, yTest, { verbose: 0 });
      const testAcc = (await evalResult[1].data())[0];
      showNotification(`Client ${clientId} Test Accuracy: ${(testAcc * 100).toFixed(2)}%`);
      xTest.dispose();
      yTest.dispose();
    }

    function createModel() {
      const model = tf.sequential();
      model.add(tf.layers.dense({ units: 64, activation: 'relu', inputShape: [784] }));
      model.add(tf.layers.dense({ units: 10, activation: 'softmax' }));
      return model;
    }

    // Update the cloneModel function
    function cloneModel(model) {
      return model.clone();
    }

    async function aggregateModels() {
      // Collect models from clients
      const clientModels = clients
        .filter((client) => client.model)
        .map((client) => client.model);

      if (clientModels.length === 0) {
        showNotification('No client models available for aggregation.');
        return;
      }

      // Average the weights
      const averagedWeights = averageWeights(clientModels);
      serverModel.setWeights(averagedWeights);

      // Evaluate on global test data
      const evalResult = serverModel.evaluate(globalTestData.x, globalTestData.y, { verbose: 0 });
      const globalAcc = (await evalResult[1].data())[0];
      updateGlobalPlot(globalAcc);
      showNotification(`Global Model Accuracy: ${(globalAcc * 100).toFixed(2)}%`);
    }

    function averageWeights(models) {
      const weightArrays = models.map((model) => model.getWeights());
      const numModels = weightArrays.length;
      const averaged = [];

      for (let layer = 0; layer < weightArrays[0].length; layer++) {
        let sum = weightArrays[0][layer].clone();
        for (let i = 1; i < numModels; i++) {
          sum = tf.add(sum, weightArrays[i][layer]);
        }
        averaged.push(tf.div(sum, numModels));
      }
      return averaged;
    }

  function initializeGlobalPlot() {
    const ctx = document.getElementById('global-accuracy-plot').getContext('2d');
    window.globalChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [{
          label: 'Global Accuracy',
          data: [],
          borderColor: '#4caf50',
          fill: false,
        }],
      },
      options: {
        responsive: true,
        scales: {
          x: { display: true, title: { display: true, text: 'Aggregation Rounds' } },
          y: { display: true, title: { display: true, text: 'Accuracy' }, min: 0, max: 1 },
        },
      },
    });
  }

  function updateGlobalPlot(accuracy) {
    window.globalChart.data.labels.push(window.globalChart.data.labels.length + 1);
    window.globalChart.data.datasets[0].data.push(accuracy);
    window.globalChart.update();
  }

  function updateClientPlot(clientId) {
    const client = clients.find((c) => c.id === clientId);
    if (!client.plot) {
      const ctx = document.getElementById(`accuracy-plot-${clientId}`).getContext('2d');
      client.plot = new Chart(ctx, {
        type: 'line',
        data: {
          labels: client.accuracyHistory.map((_, i) => i + 1),
          datasets: [{
            label: `Client ${clientId} Accuracy`,
            data: client.accuracyHistory,
            borderColor: '#2196f3',
            fill: false,
          }],
        },
        options: {
          responsive: true,
          scales: {
            x: { display: true, title: { display: true, text: 'Epochs' } },
            y: { display: true, title: { display: true, text: 'Accuracy' }, min: 0, max: 1 },
          },
        },
      });
    } else {
      client.plot.data.labels.push(client.accuracyHistory.length);
      client.plot.data.datasets[0].data.push(client.accuracyHistory[client.accuracyHistory.length - 1]);
      client.plot.update();
    }
  }

  function showNotification(message) {
    const notification = document.getElementById('notification');
    notification.innerText = message;
    notification.style.display = 'block';
    setTimeout(() => {
      notification.style.display = 'none';
    }, 5000);
  }
</script>

</body>
</html>
